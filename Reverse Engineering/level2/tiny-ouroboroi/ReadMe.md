# 🧩 Reverse Engineering Challenge: tiny-ouroboroi

# 📖 문제 개요

- 문제 이름: tiny-ouroboroi
- 출처: 드림핵
- 키워드: 동적할당,포인터,연결리스트
- 설명: 포인터와 이중포인터, 링크드 리스트의 개념을 알아야지 풀 수 있는 문제

# 🛠️ 사용 도구

- IDA / Ghidra: 정적 분석
- GDB : 동적 분석
- pycharm : 코드 분석
- 노트(?) : 직접 손으로 그리기 위한 도구

# 🚀 풀이 방법
- 연결리스트의 생성과정과 그 연결리스트에 들어가는 문자, 그리고 연결리스트에 연산을 적용하는 함수의 연산 과정을 이해 한 후 반대로 하면 됨.

# 📁 파일 구성

- main : 입력을 받으면 결과를 출력하는 프로그램
- output.bin : 플래그를 입력한 결과 내용

# 🔍 파일 동작 원리
![KakaoTalk_20251114_140941285](https://github.com/user-attachments/assets/fdd787f3-e09f-4506-ae7a-880ba05f319d)

<img width="383" height="346" alt="화면 캡처 2025-11-14 141516" src="https://github.com/user-attachments/assets/4fbc8d5f-7fd5-4184-a1e9-1791817cbc0f" />

sub_11C9에서는 V[i]에 동적할당을 한뒤 그 동적할당한 곳에 또 동적할당을 하여 문자열 abcd를 입력했다면 각 문자마다의 2진수들을 저장한다.
가령 a는 0110 0001이다. 이제 SUB_126C는 그 0110 0001을 저장한 헤더를 변경하는데 그걸 i%8만큼 위치를 변경한다.
예를 들어 abcd에서 c의 2진수는 0110 0011인데 c의 인덱스는 2므로 0110에서 두번째 1을 가리킨다.

sub_12A5는 홀수 인덱스에 위치한 문자의 0과 1을 반전시킨다.
b의 겨우 0110 0010인데 1001 1101로 바꾼다.

마지막 Sub_12EE에서는 헤더를 기준으로 저장한다. 아까 C에서 0110 0011에서 0110의 두번째 1을 가리켰으니 두번째 1을 기준으로 넣어진다.
즉 10001101로 된다. 그리고 이렇게 합쳐진 값을 다시 10진수에 해당하는 문자로 출력하게 된다.


# 🧠 접근 방법


만약 홀수 인덱스면 0,1을 반전시킨 상태에서 원래의 헤더를 찾아주면 된다.
위의 c의 경우 0110 0011인데 10001101로 바뀐 상태이니 100011 와 01를 반대로 합쳐주면 01 + 100011 -> 01100011이 되는것을 생각하면 된다.

# 📚 공부한 내용

- 연결리스트의 동적할당으로 인해 생긴 과정을 알게되었다.
- 헤더를 이용한 문자열 배치 방법에 대해 알게되었다.
- 이중 포인터의 중요성을 알게되었다.
