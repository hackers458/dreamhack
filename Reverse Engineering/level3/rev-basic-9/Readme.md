# 🧩 Reverse Engineering Challenge: rev-basic-9

📖 문제 개요

- 문제 이름: rev-basic-9
- 출처: 드림핵
- 키워드: 역연산
- 설명: 역연산을 생각하되, 좀 꼬와서 낸 문제(?)

# 🛠️ 사용 도구

- IDA / Ghidra: 정적 분석
- pycharm : 코드 작성

# 🚀 풀이 방법
- 프로그램의 동작원리를 이해한뒤 해당 인덱스에 해당하는 문자가 무엇인지 확인하는 문제

# 📁 파일 구성
- chall9.exe : 문자열을 입력하면 입력한 것에 대한 연산을 통해 메모리에 저장되있는 값과 비교하는 문제

# 🔍 파일 동작 원리

<img width="479" height="199" alt="화면 캡처 2025-11-16 173454" src="https://github.com/user-attachments/assets/fbd12467-2df6-4426-bf30-3d083639601f" />

해당 사진을 보면 입력부분이 있을탠데 FUN_140001000연산의 결과에 따라 참 거짓이 나오는 원리이다.

<img width="356" height="178" alt="화면 캡처 2025-11-16 173723" src="https://github.com/user-attachments/assets/bf13a3dc-d595-4274-a011-59e7eabaf127" />

그럼  FUN_140001000연산에는 내가 입력한 문자열의 길이를 저장하고 그 길이 + 1의 값이 8의 배수여야 하며
8글자 단위로 sub_1400010A0을 넘겨준다. 즉 12345678901234567890123을 입력했을때 12345678를 넘겨준다.

memcmp는 내 문자열의 연산 결과를 메모리에 있는 값과 비교한다.


<img width="627" height="337" alt="화면 캡처 2025-11-16 173936" src="https://github.com/user-attachments/assets/19963109-fe50-47c9-a8a1-f0a1821d374a" />

여기서 result의 역할은 없다..
v5에 I_am_KEY를 저장하며
보면 저 이중 반복문의 원리는 ROR(내가 입력한값[j+1] & 7] + data(메모리값)[v5[j] ^ v2] , 5)를 수행한 후 그 값을
내가입력한 값[j+1&7]에 저장한다.

예를 들면 12345678이 왔으면 ROR( '2' + data[ 'I' ^ '1'] , 5)가 되는 것을 알 수 있다. 
즉 v2는 앞의 내가 입력한 값의 전 인덱스의 값, 즉 v2가 4면 앞에는 3이 된다는 것이다. 
그리고 j + 1 & 7 부분에서 j를 0~7을 입력하면 해당 연산의 결과는 1~7,0이 된다는 것을 알 수 있다.

이 과정을 반복하여 총 내가 입력한 값의 연산 결과랑 메모리에 저장된 값이랑 비교한다.

# 🧠 접근 방법

메모리에 저장된 값을 abcdefgh... 라고 하면 첫번째 8글자를 예를 들어보겠습니다.

이걸 역연산하기 위해선 j = 7과 j != 7인 경우를 나뉘어야 합니다. j + 1 & 7를 했을때 1 ~ 7, 0이 나오는 것과 같이 순차적으로 진행되지 않기 때문입니다.

우선 식을 abcd..로 일반화하면 하면
j = 7일때
h = ROR(위의 연산)이 되고
ROL(h) = 위의 연산이 됩니다.
위의 연산 = 연산 전 값 + data[I_am_Key[j] ^ V2]인데 여기서 V2는 연산 전 값보다 전 인덱스 값이니 j = 0일때의 값을 사용하면 됩니다. 즉 a가 됩니다.
그렇다면 ROL(h) = 연산전 값 + data[y ^ a]이 되고 data를 왼쪽으로 옮기면 연산 전 값을 구할 수 있습니다.
즉 V2의 역할이 무엇인지만 알면 되는 문제입니다.


j= 7이 아닐때는 순차적으로 진행이 되니 
위에 똑같이 하돼, 연산 전 값의 인덱스 + 1에 해당하는 값을 v2에 넣으면 됩니다.


# 📚 공부한 내용

- 역연산의 과정은 똑같으나 해당 변수가 무엇을 가리키는 건지, 역연산이 무조건(?) 되기에(안되면 브루트포스..) 어떻게 식을 쓰고 옮길지를 배웠습니다.
