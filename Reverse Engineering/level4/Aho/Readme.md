# 🧩 Reverse Engineering Challenge: Aho

## 📖 문제 개요
- **문제 이름**: Aho  
- **출처**: 드림핵  
- **키워드**: DFA,BFS
- **설명**: 바이너리로 된 미로를 풀어 특정 조건(도착점)을 구하는 문제

---

## 🛠️ 사용 도구
- **IDA**: 정적 분석  
- **PyCharm**: 코드 작성  

---

## 🚀 풀이 방법
- DFA 표를 만들어(이미 바이너리에 데이터가 있다.) BFS로 탐색하여 구하는 문제

---

## 📁 파일 구성
- **main** : 섞인 문자열을 출력하고, 그에 맞는 원본 문자열을 입력하는 프로그램  

---

## 🔍 파일 동작 원리

| 단계 | 이미지 | 설명 |
|------|--------|------|
| Step 1 | <img width="650" height="658" alt="화면 캡처 2026-02-04 181132" src="https://github.com/user-attachments/assets/1324071a-0b04-4263-bd0b-fe86246a57af" />| 해당 코드는 문자열 13길이를 받아 byte_46B0에 해당하는 문자만 입력받게 한다. 그 후 12번 동안 반복하는데 만약 dword_4024[20 * v4 + 2 * j]이 0보다 크면 v5를 1<<dword 값과 xor하여 v5를 저장하고 v4를 unk_4020+20...값을 저장한다. 즉 구해야 하는건 v5의 결과가 15가 나와야 하는 것이다. |

---

## 🧠 접근 방법
- `dword_4020`은 4바이트 값들의 배열이다.  

| 이미지 | 설명 |
| --- | --- |
| <img width="671" height="885" alt="화면 캡처 2026-02-04 181710" src="https://github.com/user-attachments/assets/a4884388-bd6e-4ae7-9bb9-5623bb8826b0" />| 사실 unk_4620과 dword_4024는 각각 홀수 인덱스와 짝수 인덱스만 접근한다. 저걸 이제 배열로 나타내면 저렇게 보이는데.. bit_set의 2 3 4만 꼭 지나야지 15가 나온다. 그 문자열을 찾기 위해 bfs 알고리즘을 사용하면 된다. 초기는 [(0, "", 0b0000)] 이렇게 잡아 예를 들어 1단계(1글자)이면[(10, "a", 0b0000), (2, "s", 0b0000), (1, "r", 0b0000), ...]  이런식으로 접근하면된다. |

---

## 😪 막힌 부분
- 이걸 재귀함수로 접근했더니 시간이 엄청 오래 걸렸다.(Z3로도 코드를 짜보니까 코드가 복잡했으며 angr로도 했으나 잘 안나왓다.)  
- dword_4024 및 unk_4020를 단순 데이터로 보았더니 DFA라는게 안보였다. 이걸 배열로 봤으면 좋았을탠데.. -> 데이터를 시각적으로 접근하는 걸 생각해야겠다.

---

## 📚 공부한 내용
- 학교에서 배운 DFA 알고리즘이 여기서 쓰일줄은 몰랐다.. 이론은 알고 있으나 데이터가 그런 역할을 할 줄은 몰랐다.
- 앞으로 미로 관련 문제는 DFS/BFS를 생각해보아야 겠다.(백준에서도 미로 관련 문제는 대부분 저 알고리즘을 썼던것 같았다.. 근데 이러면 리버싱 문제가 아닌 알고리즘 문제가 아닌가????)

---

## 📗 비고
- 정렬 문제라는 건 보자마자 알았다.  
- 백준 문제를 풀다 보면 특정 조건(`lambda`)을 두고 정렬하는 경우가 많아, 그 경험 덕분에 접근이 조금 더 수월했다.  
