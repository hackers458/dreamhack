# 🧩 Reverse Engineering Challenge: simple_crack_me_2
📖 문제 개요
- 문제 이름: simple_crack_me_2
- 출처: 드림핵
- 키워드: 역연산, 자료형
- 설명: 프로그램의 동작원리를 이용하고 이를 역연산 하면 플래그 도출

# 🛠️ 사용 도구
- IDA / Ghidra: 정적 분석
- gdb / pwndbg: 동적 분석
- Python: 결과 값 복호화

# 🚀 풀이 방법
- 결과 값을 비교하는 곳을 확인한 뒤 암호화 하는 과정에 사용되는 함수들을 분석한다. 그 후 결과 값에 반대로 적용하면 됨.
# 📁 파일 구성
- prob : 프로그램에 스트링을 넣으면 결과값과 비교하여 맞으면 플래그를 출력.(단순 조건 조작으로 플래그를 얻을 수 없으며 입력 값이 맞아야 함)

# 🔍 파일 동작 원리
<img width="315" height="451" alt="화면 캡처 2025-10-31 211012" src="https://github.com/user-attachments/assets/b2a6d01c-788f-498b-9b10-659481dbffba" />

answer = "F8 E0 E6 9E 7F 32 68 31 05 DC A1 AA AA 09 B3 D8 41 F0 36 8C CE C7 AC 66 91 4C 32 FF 05 E0 D9 91"로 되있으며

INPUT_XOR :
문자열을 str라 하고 문자열을 가리키는 인덱스를 i라 하며
str = abcdefg
i = 6일때 str[i] = g이며
두번째 인자로 받은 데이터 리스트(0xDE,0xAD,0xBE,0xEF처럼 두번째 파라미터로 받은 것)의 길이를 len == 4이라 하면
i % len ( 6 % 4 == 2 )의 값을 데이터 리스트에서 갖고옵니다.
즉 데이터리스트[2] = BE를 갖고와 g(아스키코드값) xor BE 연산을 합니다. 이 과정을 인덱스 0 ~ 문자열 길이 -1 까지 반복합니다.

INPUT_PLUS:
문자열 하나하나 아스키코드에 두번째 파라미터 값을 더합니다. 중요한 부분은 char로 저장하기에 문자 + 두번째 파라미터값이 256을 넘으면 오버플로우 되기에 만약 256보다 크면 256을 빼줍니다.

INPUT_MINUS:
문자열 하나하나 아스키코드에 두번째 파라미터 값을 빼줍니다. 중요한 부분은 char로 저장하여 만약 0 미만으로 넘어가면 오버플로우 되기에 뺀 값의 2의 보수를 취해야 합니다.
즉 -78인 경우 78을 2의 보수로 한 값을 저장하면 됩니다.






# 📚 공부한 내용
- ^ 가 xor라는걸 다시 한번 되새겼습니다(AND 연산 인줄 알고 해맸다가 다시 봣더니 XOR이었습니다..)
- 자료형을 잘 봐야 하는 걸 느끼게 해주었습니다. 연산 결과를 char로 저장하다 보니 범위에 맞게 조절해야하는 것을 느꼈습니다.
