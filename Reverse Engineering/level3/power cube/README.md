# 🧩 Reverse Engineering Challenge: power cube

📖 문제 개요

- 문제 이름: power cube
- 출처: 드림핵
- 키워드: SHA256, 오일러 , Carmichael
- 설명: 제곱에서 지수를 최대한 줄여야 하는 문제

# 🛠️ 사용 도구

- IDA / Ghidra: 정적 분석
- pycharm : 코드 작성

# 🚀 풀이 방법

- 오일러 공식과 카미첼 공식을 이용하여 지수를 최대한 줄이고 SHA-256을 한 결과를 이용하여 DH를 구하면 된다.
# 📁 파일 구성

- chall : 플래그를 출력하는 프로그램

# 🔍 파일 동작 원리
<img width="578" height="407" alt="화면 캡처 2025-12-24 174922" src="https://github.com/user-attachments/assets/73364f6c-7962-4ce5-9429-f7253d53be56" />

해당 빨간 줄을 보면 x에는 0xdeadbeefdeadbeef가 저장되어 있으며 저 함수에
x = x^3를 하고 이 걸 저 어마무시한 숫자를 반복한다.
그러면 3^어마무시한 수를 제곱하는데, 해당 값은 unsigned 64이므로 자동적으로 mod 2^64를 실행한다.
즉, 모든 연산은 2^64로 나눈 나머지로 계산된다.
그러면 계산해야 하는 값은 x ^(3^n) mod 2^64인데, x는 홀수이므로
Carmichael λ를 쓰면 된다.
여기서 λ(2^64) = 2^62이며, 이 의미는 2^64의 서로소 들 중 제곱을 하여 모듈러 연산 2^ 64를 했을때
1이 나오는 가장 최대의 수를 의미한다. (Notion에 기초를 적어놨으니 자세히는 생략)
그러므로 a^λ(m) ≡ 1 (mod m) 이 식이 성립하므로
X0^(2^62) ≡ 1 (mod 2^64)
즉, X0를 2^62번 곱하면 항상 1 mod 2^64

→ 주기가 2^62 생김

주기가 2^62이므로 거듭제곱을 줄일 수 있음:

X0^(3^N) ≡ X0^(3^N mod 2^62) (mod 2^64)
3^N 전체가 아니라 2^62로 나눈 나머지만 알면 충분
이것이 바로 3^N mod 2^62가 나온 이유


X0^(3^N) mod 2^64 계산 → 직접 불가
λ(2^64) = 2^62 → 주기 생김
따라서 지수 3^N을 2^62로 나눈 나머지로 줄임
결과적으로 3^N mod 2^62만 계산하면 됨

# 🧠 접근 방법
저 공식을 이용하면 된다.

# 📚 공부한 내용
모듈러 연산, 오일러 연산, Carmichael에 대해 알게 되었다.
