# 🧩 Reverse Engineering Challenge: Testify

📖 문제 개요

- 문제 이름: Testify
- 출처: 드림핵
- 키워드: Aho–Corasick, 브루트포스(?)
- 설명: 알고리즘을 이해하고 플래그를 브루트포스로 익스플로잇하는 문제

# 🛠️ 사용 도구

- visual studio : 코드 파일 분석
- vscode : 코드 작성

# 🚀 풀이 방법

- 알고리즘을 이해 한 뒤 플래그에 들어있는 문자를 하나 정하여 앞 뒤로 넣으면서 PURE를 확인한다.

# 📁 파일 구성

- chal.c / chal : 알고리즘 파일

# 🔍 파일 동작 원리
![KakaoTalk_20251222_024937209](https://github.com/user-attachments/assets/6bb07d35-0306-410d-b067-3dcb996e8eef)
그림이 좀 이상하긴 하지만...
간단히 설명하자면 head를 기준으로 
내가 amount = 3, abcd, afgh 1234를 입력하면
head에서 wire[0~256]씩 차례대로 넣지만 만약 같은 부분이 있다면, 즉 abcd와 afgh에서 a 가 같으면 abcd를 먼저 입력했으므로 a로 들어가 bcd를 저장한다.
그리고 fail은, 즉 FLAG와 내가 입력한 값이 같지 않으면 헤드로 돌아간다는 것 뿐이다.

하지만 이 문제는 그냥 flag안에 문자열이 일치하는 부분이 있으면 pure 아니면 fail을 반환한다는걸 알면 된다. 가령 flag에 12345가 있고 34만 입력해도 pure가 나온다는것이다.

# 🧠 접근 방법
pure를 반환하는 문자 1개를 정해보자, 1을 정하게 되면 1을 기준으로 앞 뒤로 하나씩 붙여보는거다. 예를들어 1a는 fail인데 1b는 pure이면
1ba, 1bb 이런식으로 나아가는거다. 이러다가 멈추는 부분이 잇는데, 이는 끝 부분을 의미하는거다.
이제 1(플래그 뒷부분이면)a1(플래그 뒷부분)으로 앞 부분을 하나하나 찾는것이다.
그리곤 같은 패턴이 있을 수 있으므로 나는 3개씩 시작했다. 예를 들어 1234567890abcdef면 def부터 defa defb 이렇게 찾도록 했다.


# 📚 공부한 내용
- 연결 리스트에 한층 더 강해졌으며 저 알고리즘이 Aho–Corasick와 연관이 있다는 것을 알게 되었다.
