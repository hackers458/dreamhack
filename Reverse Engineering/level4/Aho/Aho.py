from collections import deque


alphabet = "aehinrstuw"

next_states = [
    [10, 0, 0, 0, 0, 2, 1, 5, 0, 12],
    [10, 0, 0, 18, 0, 2, 1, 5, 0, 12],
    [6, 0, 0, 0, 0, 2, 1, 5, 0, 12],
    [10, 0, 0, 18, 0, 2, 1, 5, 0, 12],
    [6, 0, 0, 0, 0, 2, 1, 5, 0, 12],
    [10, 0, 11, 0, 0, 2, 1, 5, 0, 12],
    [10, 0, 0, 0, 17, 2, 16, 5, 0, 15],
    [10, 0, 0, 0, 0, 2, 1, 5, 0, 12],
    [10, 0, 0, 0, 0, 2, 1, 5, 0, 12],
    [10, 0, 0, 0, 0, 2, 1, 5, 0, 12],
    [10, 0, 0, 0, 17, 2, 16, 5, 0, 12],
    [10, 0, 0, 9, 0, 2, 1, 5, 8, 12],
    [10, 14, 0, 0, 0, 2, 1, 5, 0, 12],
    [10, 0, 0, 18, 0, 2, 1, 5, 0, 12],
    [10, 0, 0, 0, 0, 4, 1, 5, 0, 12],
    [10, 14, 0, 0, 0, 2, 1, 5, 0, 12],
    [10, 0, 0, 19, 0, 2, 1, 5, 0, 12],
    [10, 0, 0, 0, 0, 2, 3, 5, 0, 12],
    [10, 0, 0, 0, 7, 2, 13, 5, 0, 12],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
]

bit_sets = [
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, 2],
    [-1, -1, -1, -1, -1, 3, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, 6, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, 5, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, 0, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, 4, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
    [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1],  # State 19
]

def solve_dfa():

    queue = deque([(0, "", 0)])
    solutions = []
    visited = set()
    
    while queue:
        state, path, bits = queue.popleft()
        state_key = (state, len(path), bits)
        if state_key in visited:
            continue
        visited.add(state_key)
        if len(path) == 13:
            if bits == 15: 
                solutions.append(path)
            continue
        for char_idx in range(10):
            next_state = next_states[state][char_idx]
            if next_state == -1:
                continue
            
            new_bits = bits
            bit_to_set = bit_sets[state][char_idx]
            if bit_to_set >= 0:
                new_bits |= (1 << bit_to_set)
            
            new_path = path + alphabet[char_idx]
            queue.append((next_state, new_path, new_bits))
    
    return solutions

if __name__ == "__main__":
    solutions = solve_dfa()
    if solutions:
        for i, sol in enumerate(solutions[:20], 1):
            print(f"  {i}. {sol}")
