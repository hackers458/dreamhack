# 🧩 Reverse Engineering Challenge: secret_message
📖 문제 개요
- 문제 이름: secret_message
- 출처: 드림핵
- 키워드: 인코딩 원리 분석
- 설명: 인코딩의 원리를 분석한뒤 원본을 구하는 문제.(인코딩을 반대로 하는게 아닌 문제, 알고리즘을 이해하는 문제)

# 🛠️ 사용 도구
- IDA / Ghidra: 정적 분석
- Python: 인코딩 복호화 코드 작성

# 🚀 풀이 방법
- IDA의 main함수 부분 -> sub_7FA 함수에 인코딩 알고리즘이 있으며 이 인코딩 알고리즘을 이해하면 역으로 할 수 있는 문제.

# 📁 파일 구성
- secretMessage.enc : prob을 실행한 인코딩된 파일
- prob : 인코딩 하는 프로그램
- imageviewer.py : 복호화된 raw 파일을 image 파일로 만들어줌

# 🔍 파일 동작 원리
<img width="347" height="849" alt="화면 캡처 2025-10-30 142149" src="https://github.com/user-attachments/assets/6acb7e4c-bb41-46cc-b3f8-4f2cc23c846a" />

1번에서 파일 바이트 한개를 읽고 씁니다. 가령 FF를 읽으면 getbyte가 x와 같지 않으니 x = FF가 됩니다.
하지만 다음 바이트를 읽고 썼을때 만약 x와 같으면 그 다음걸 읽습니다. 만약 계속 읽다가 다른게 나오면 읽은 횟수와 다른게 나온걸 바이트에 씁니다.
가령 FF FF 3C F0이 있을때 각 변수의 변화는
getbyte = FF -> FF ............ FF -> F0
x = -1 -> FF -> F0
y = 0 -> 3C

즉 3C의 의미는 FF가 3C개 만큼 있고 그 다음에 F0이 온다는 것이다.
하지만 만약 FF FF 3C F0 FE 00 FF 9F 이렇게 온다면?
FF FF 3C F0까진 동일하나 다음에 오는 FE는 F0과 다르기에 그냥 FE 00 FF 9F 이렇게 작성이 된다.
즉 이 알고리즘은 긴 바이트를 줄인 뒤 그 횟수를 적어놓은 알고리즘




# 📚 공부한 내용
- 이미지 인코딩 문제를 처음 풀어보았습니다. 지금까지 대회나 CTF에서 이미지 문제를 못풀었는데, 이렇게 기초적인 문제를 풀음으로써 한 단계 다가갈 수 있다고 생각합니다..
- 인코딩 알고리즘을 반대로 하면 된다는 편견을 깼습니다.
- 직접 손으로 노트에다가 변수의 변화 과정을 보며 어떻게 작동하는지 이해하는 과정이 도움이 되나 시간이 좀 많이 걸리는 느낌입니다.. 이 부분을 어떻게 해야할지 고민하겠습니다.
